<html>
<head>
    <title>Open Sailing - A Ship Game in OpenGL</title>
    <style type="text/css">
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            width: 80%;
            margin: auto;
            line-height: 1.5;
        }

        img {
            display: block;
            margin: auto;
            max-width: 300px;
            width: 100%;
        }

        figcaption {
            font-size: small;
            text-align: center;
        }
    </style>
</head>
<body>
<h1 style="margin-bottom: 0">Open Sailing</h1>
<h3 style="margin-top: 0">A Ship Game in OpenGL</h3>
<p>
    <i>Autore: Lorenzo Vainigli<br/>
        Corso di Grafica a.a. 2017/18, Laurea Magistrale in Informatica<br/>
        Università di Bologna</i>
</p>
<h2>Indice</h2>
<ul>
    <a href="#intro">
        <li>Introduzione</li>
    </a>
    <a href="#caratteristiche">
        <li>Caratteristiche</li>
    </a>
    <ul>
        <li>Telecamere</li>
        <li>Opzioni</li>
    </ul>
    <a href="#librerie">
        <li>Librerie utilizzate</li>
    </a>
    <a href="#svolgimento">
        <li>Svolgimento del progetto</li>
    </a>
    <ul>
        <li>Modello della barca</li>
        <li>Ambiente di gioco</li>
        <li>Luci</li>
        <li>Ombre e shaders</li>
        <li>Trasparenze</li>
    </ul>
    <a href="#funzioni-obbligatorie">
    <li>Funzioni grafiche obbligatorie</li>
    </a>
    <a href="#come-si-gioca">
    <li>Come si gioca</li>
    </a>
</ul>
<a id="intro">
    <h2>Introduzione</h2>
</a>
<p>
    Open Sailing è un piccolo gioco realizzato con le librerie SDL2 e OpenGL. L'utente si trova al comando di
    un'imbarcazione nel mezzo al mare ed è circondato da numerose boe a cui sono fissate delle bandiere. Il suo obiettivo è
    raccogliere tutte le boe nel minor tempo possibile.
</p>
<a id="caratteristiche">
    <h2>Caratteristiche</h2>
</a>
<p>
    Di seguito sono riportate le caratteristiche principali del gioco.
</p>
<h3>Telecamere</h3>
<p>
    Durante il gioco l'utente può scegliere tra le seguenti telecamere del gioco:
    <ul>
    <li>
        <b>Telecamera sul retro della barca</b>: è la telecamera predefinita e quella che offre la miglior visuale sull'area
        di mare che si trova davanti all'imbarcazione.
    </li>
    <li>
        <b>Telecamera a bordo della barca</b>: è la telecamera più realistica perché è fissata sul ponte di comando; la vista
        riproduce ciò che vedrebbe il pilota dell'imbarcazione.
    </li>
    <li>
        <b>Telecamera libera puntata sulla barca</b>: offre la possibilità all'utente di ruotare di 360 gradi attorno al
        modello 3D dell'imbarcazione (ovvero all'origine degli assi nello spazio della barca).
    </li>
    <li>
        <b>Telecamera libera puntata sul centro del mondo</b>: come la precedente ma questa telecamera, a differenza delle
        altre, è sempre puntata al centro del mondo (ovvero all'origine degli assi nello spazio mondo).
    </li>
    </ul>
</p>
<h3>Opzioni di rendering</h3>
<p>
    Il gioco dispone di alcune opzioni di rendering:
    <ul>
    <li>
        <b>Attiva/disattiva wireframe</b>: permette di visualizzare i wireframe, ovvero gli spigoli che compongono i
        poligoni della scena. <br/> Dal punto di vista dell'implementazione, vengono intercambiate le funzioni
        <code>glBegin(GL_TRIANGLES)</code>/<code>glBegin(GL_QUADS)</code> con <code>glBegin(GL_LINE_LOOP)</code>.
    </li>
    <li>
        <b>Attiva/disattiva ombre</b>: permette abilitare o disabilitare il rendering delle ombre utilizzando gli shader.
        <i>Funziona solo se è attivo il rendering avanzato.</i>
    </li>
    <li>
        <b>Attiva/disattiva nebbia/foschia</b>: visualizza la foschia chiara in lontananza. <i>Funziona solo se è attivo
        il rendering avanzato.</i>
    </li>
    <li>
        <b>Attiva/disattiva rendering avanzato (shader)</b>: abilita/disabilità gli shader, con i quali si ha una migliore
        resa grafica.
    </li>
    </ul>
</p>
<a id="librerie">
    <h2>Librerie utilizzate</h2>
</a>
<p>
    Questo gioco è stato programmato in linguaggio C/C++ utilizzando SDL2, OpenGL e le librerie di supporto GLU, GLUT, GLEW e GLFW.
</p>
<a id="svolgimento">
    <h2>Svolgimento del progetto</h2>
</a>
<p>
    Il lavoro è iniziato partendo dal codice di <i>progettoCar3</i>. In un primo momento è stato effettuato un refactoring
    del codice per renderlo object-oriented, per poi procedere all'implementazione di nuove funzioni.
</p>
<h3>Modello della barca</h3>
<p>
    Il modello della barca comandata dall'utente è memorizzato in un file OBJ e viene caricato e renderizzato con le stesse
    modalità del modello della macchina che vi era in precedenza. Tale modello è stato scaricato da
    <a href="http://www.cadnav.com/3d-models/model-37131.html">questa pagina</a>.
</p>
<a href="../project/assets/ship/screen/cadnav-16110H23114.jpg">
    <figure>
        <img src="../project/assets/ship/screen/cadnav-16110H23114.jpg">
        <figcaption>Modello della barca disponibile su <i>cadnav.com</i>. Click per ingrandire.</figcaption>
    </figure>
</a>
<h4>Texturing</h4>
<p>
    Nel pacchetto del modello sono presenti le immagini da utilizzare come texture e il file OBJ contiene le coordinate per
    applicarle al modello. Tuttavia, ritenendo troppo oneroso implementare una funzione per il parsing delle coordinate
    texture presenti nel file OBJ, ho optato per una soluzione più comoda: il file <i>textures.dat</i> in
    <i>project/assets/ship/</i> contiene una mappa, costruita manualmente da me, tra identificativo della faccia e
    numero della texture da applicare ad essa. Il calcolo delle coordinate texture è effettuato dal programma secondo
    la modalità <i>OBJECT LINEAR</i>.<br/>
    Con qualche imprecisione, è stato replicato l'aspetto originale della barca.
</p>
<h5>Foto personale</h5>
<p>
    Come richiesto dalle specifiche, sulle fiancate della barca è stata apposta una mia foto personale.
</p>
<a href="images/foto_su_mesh.png">
    <figure>
        <img src="images/foto_su_mesh.png">
        <figcaption>Foto personale applicata sulle fiancate della barca. Click per ingrandire.</figcaption>
    </figure>
</a>
<h3>Ambiente di gioco</h3>
<p>
    La topologia dell'ambiente di gioco, ovvero il mare su cui naviga la barca e il cielo, è rimasta sostanzialmente
    invariata rispetto al progetto di partenza: il mare è un piano suddiviso in poligoni bidimensionali e il cielo è una
    sfera.
</p>
<h4>Mare</h4>
<p>
    I poligoni che compongono il mare sono concettualmenti divisi in due gruppi: il mare in prossimità e il mare in
    lontananza. Il motivo di questa suddivisione è semplice: la creazione del movimento delle onde nel mare comporta
    l'inserimento di più poligoni e di conseguenza il rendering diventa più pesante. <br/>
    È stata valutata la performance dell'applicazione nel caso che tutto il mare avesse lo stesso livello di dettaglio,
    ma ciò causava un drastico calo degli fps. Ho deciso quindi di adottare un compromesso: lasciare la zona di mare
    lontana dalla posizione della barca ad un livello di dettaglio minore rispetto alla zona nei dintorni della barca,
    ovvero poligoni più grandi e senza movimento delle onde.<br/>
    Questa scelta è anche dettata dal fatto le zone lontane dalla barca vengono visualizzare solo in modalità "camera libera
    sul mondo", ma questo avviene in casi molto rari.
</p>
<h5>Mare in prossimità</h5>
<p>
    Con questo termine si intende la zona di mare che circonda il punto dove si trova la barca in un raggio specificato
    nel codice sorgente. Questa parte della scena di gioco è formata da quadrati, ognuno dei quali composto di due triangoli,
    dispositi su righe e colonne rispetto agli assi <i>X</i> e <i>Z</i>.<br/>
    L'animazione dei triangoli è resa possibile da una funzione che combina il tempo di gioco (<code>SDL_GetTicks()</code>) e le
    funzioni <code>cos(x)</code> e <code>sin(x)</code> per creare un "effetto onda" sull'asse <i>Y</i>.<br/>
    La suddivisione in triangoli ha l'unico scopo di rendere l'animazione più dettagliata.
</p>
<h5>Mare in lontananza</h5>
<p>
    Questa parte, che compone le zone che vanno dagli estremi del mare di prossimità al limite del mondo di gioco (definito
    dalla sfera che crea il cielo) è composta da quadrati non animati e non suddivisi in triangoli.
</p>
<a id="funzioni-obbligatorie">
    <h2>Funzioni grafiche obbligatorie</h2>
</a>
<a id="come-si-gioca">
    <h2>Come si gioca</h2>
</a>
<p>
    Lo scopo del gioco è raccogliere tutte le boe nel minor tempo possibile.<br/>
    Appena avviata l'applicazione l'utente viene mostrata la seguente schermata:
</p>
<a href="images/schermata_iniziale.png">
    <figure>
        <img src="images/schermata_iniziale.png">
        <figcaption>Schermata iniziale. Click per ingrandire.</figcaption>
    </figure>
</a>
<p>
    Nella finestra vengono mostrate le informazioni relative allo scopo del gioco, ai comandi, l'indicazione di premere
    <i>B</i> se si vuole cambiare il numero di boe (l'utente può inserire un numero arbiatrario tra 1 e 100 compresi)
    e l'azione da fare per iniziare il gioco e contestualmente attivare il cronometro: muovere la barca.<br/>
    Sul HUD (Heads Up Display), in basso a destra, viene mostrata una mappa del mondo di gioco in cui la freccia rossa rappresenta la barca,
    la sua posizione e il suo orientamento. I punti verdi sono le boe che rimangono da catturare.
    In alto a sinistra si trovano i pulsanti da premere per i relativi comandi (pausa e lista dei comandi), mentre sempre
    in alto ma sulla destra sono mostrati gli FPS.<br/>
    In basso a sinistra è presente il contatore delle boe catturate.<br/>
    Durante il gioco la schermata appare in questo modo:
</p>
<a href="images/in_game.png">
    <figure>
        <img src="images/in_game.png">
        <figcaption>Schermata di gioco in-game. Click per ingrandire.</figcaption>
    </figure>
</a>
<p>
    Durante il gioco il giocatore può mettere in pausa e riprendere in un istante successivo.
    <i>Il gioco non possiede un sistema di salvataggio e quindi quando si chiude l'applicazione tutti i salvataggi andranno persi.</i>
    Una volta che l'utente avrà raccolto tutte le boe il gioco termina mostrando il tempo complessivo; da questa schermata
    si può premere <i>N</i> avviando una nuova sessione di gioco.
</p>
<a href="images/gioco_finito.png">
    <figure>
        <img src="images/gioco_finito.png">
        <figcaption>Schermata di riepilogo a conclusione del gioco. Click per ingrandire.</figcaption>
    </figure>
</a>
</body>
</html>